// Generated by CoffeeScript 1.6.3
/**
# Player Entity
*/


(function() {
  game.PlayerEntity = me.Entity.extend({
    init: function(x, y, settings) {
      this._super(me.Entity, 'init', [x, y, settings]);
      this.body.setVelocity(3, 15);
      me.game.viewport.follow(this.pos, me.game.viewport.AXIS.BOTH);
      this.alwaysUpdate = true;
      this.renderable.addAnimation('walk', [0]);
      this.renderable.addAnimation('stand', [0]);
      return this.renderable.setCurrentAnimation('stand');
    },
    update: function(dt) {
      if (me.input.isKeyPressed('left')) {
        this.renderable.flipX(true);
        this.body.vel.x -= this.body.accel.x * me.timer.tick;
        if (!this.renderable.isCurrentAnimation('walk')) {
          this.renderable.setCurrentAnimation('walk');
        }
      } else if (me.input.isKeyPressed('right')) {
        this.renderable.flipX(false);
        this.body.vel.x += this.body.accel.x * me.timer.tick;
        if (!this.renderable.isCurrentAnimation('walk')) {
          this.renderable.setCurrentAnimation('walk');
        }
      } else {
        this.body.vel.x = 0;
        this.renderable.setCurrentAnimation('stand');
      }
      if (me.input.isKeyPressed('jump')) {
        if (!this.body.jumping && !this.body.falling) {
          this.body.vel.y = -this.body.maxVel.y * me.timer.tick;
          this.body.jumping = true;
          me.audio.play('jump');
        }
      }
      this.body.update(dt);
      me.collision.check(this);
      return this._super(me.Entity, 'update', [dt]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
      switch (response.b.body.collisionType) {
        case me.collision.types.WORLD_SHAPE:
          if (other.type === 'platform') {
            if (this.body.falling && !me.input.isKeyPressed('down') && response.overlapV.y > 0 && ~~this.body.vel.y >= ~~response.overlapV.y) {
              response.overlapV.x = 0;
              return true;
            }
            return false;
          }
          break;
        case me.collision.types.ENEMY_OBJECT:
          if (response.overlapV.y > 0 && !this.body.jumping) {
            this.body.falling = false;
            this.body.vel.y = -this.body.maxVel.y * me.timer.tick;
            this.body.jumping = true;
            me.audio.play('stomp');
          } else {
            this.renderable.flicker(750);
          }
          return false;
        default:
          return false;
      }
      return true;
    }
  });

  /**
  # Coin Entity
  */


  game.CoinEntity = me.CollectableEntity.extend({
    init: function(x, y, settings) {
      this._super(me.CollectableEntity, 'init', [x, y, settings]);
    },
    onCollision: function(response, other) {
      me.audio.play('cling');
      game.data.score += 250;
      this.body.setCollisionMask(me.collision.types.NO_OBJECT);
      me.game.world.removeChild(this);
      return false;
    }
  });

  /**
  # Enemy Entity
  */


  game.EnemyEntity = me.Entity.extend({
    init: function(x, y, settings) {
      var height, width;
      settings.image = 'wheelie_right';
      width = settings.width;
      height = settings.height;
      settings.spritewidth = settings.width = 64;
      settings.spritewidth = settings.height = 64;
      this._super(me.Entity, 'init', [x, y, settings]);
      x = this.pos.x;
      this.startX = x;
      this.endX = x + width - settings.spritewidth;
      this.pos.x = x + width - settings.spritewidth;
      this.updateBounds();
      this.walkLeft = false;
      this.body.setVelocity(4, 6);
    },
    update: function(dt) {
      if (this.alive) {
        if (this.walkLeft && this.pos.x <= this.startX) {
          this.walkLeft = false;
        } else if (!this.walkLeft && this.pos.x >= this.endX) {
          this.walkLeft = true;
        }
        this.renderable.flipX(this.walkLeft);
        this.body.vel.x += this.walkLeft ? -this.body.accel.x * me.timer.tick : this.body.accel.x * me.timer.tick;
      } else {
        this.body.vel.x = 0;
      }
      this.body.update(dt);
      me.collision.check(this);
      return this._super(me.Entity, 'update', [dt]) || this.body.vel.x !== 0 || this.body.vel.y !== 0;
    },
    onCollision: function(response, other) {
      if (response.b.body.collisionType !== me.collision.types.WORLD_SHAPE) {
        if (this.alive && response.overlapV.y > 0 && response.a.body.falling) {
          this.renderable.flicker(750);
        }
        return false;
      }
      return true;
    }
  });

}).call(this);
